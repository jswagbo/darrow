import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun, 
  HeadingLevel,
  AlignmentType,
  UnderlineType
} from 'docx'
import { DocumentType } from './utils'

export interface DocxGenerationOptions {
  title: string
  content: string
  docType: DocumentType
  metadata?: {
    author?: string
    company?: string
    created?: Date
  }
}

/**
 * Convert HTML content to DOCX paragraphs
 */
function htmlToDocxParagraphs(html: string): Paragraph[] {
  // Simple HTML to DOCX conversion
  // For MVP, we'll handle basic formatting
  
  const paragraphs: Paragraph[] = []
  
  // Split by HTML paragraphs and headers
  const htmlSections = html
    .replace(/<\/p>/g, '</p>\n')
    .replace(/<\/h[1-6]>/g, '</h>\n')
    .split('\n')
    .filter(section => section.trim())

  for (const section of htmlSections) {
    const cleanText = section
      .replace(/<[^>]*>/g, '') // Remove HTML tags for now
      .trim()
    
    if (!cleanText) continue

    // Detect heading levels
    if (section.includes('<h1')) {
      paragraphs.push(
        new Paragraph({
          text: cleanText,
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 240 }
        })
      )
    } else if (section.includes('<h2')) {
      paragraphs.push(
        new Paragraph({
          text: cleanText,
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 200 }
        })
      )
    } else if (section.includes('<h3')) {
      paragraphs.push(
        new Paragraph({
          text: cleanText,
          heading: HeadingLevel.HEADING_3,
          spacing: { after: 160 }
        })
      )
    } else {
      // Regular paragraph with basic formatting
      const textRuns: TextRun[] = []
      
      // Handle bold text
      if (section.includes('<strong>') || section.includes('<b>')) {
        // For MVP, just add the text as bold if it contains bold tags
        textRuns.push(
          new TextRun({
            text: cleanText,
            bold: true
          })
        )
      } else if (section.includes('<em>') || section.includes('<i>')) {
        // Handle italic
        textRuns.push(
          new TextRun({
            text: cleanText,
            italics: true
          })
        )
      } else {
        textRuns.push(
          new TextRun({
            text: cleanText
          })
        )
      }
      
      paragraphs.push(
        new Paragraph({
          children: textRuns,
          spacing: { after: 120 }
        })
      )
    }
  }

  // If no paragraphs were created, create a default one
  if (paragraphs.length === 0) {
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: html.replace(/<[^>]*>/g, '').trim() || 'Empty document'
          })
        ]
      })
    )
  }

  return paragraphs
}

/**
 * Generate DOCX document from HTML content
 */
export async function generateDocx(options: DocxGenerationOptions): Promise<Uint8Array> {
  const { title, content, docType, metadata } = options
  
  // Convert HTML to paragraphs
  const paragraphs = htmlToDocxParagraphs(content)
  
  // Add title at the beginning
  const documentParagraphs = [
    new Paragraph({
      children: [
        new TextRun({
          text: title,
          bold: true,
          size: 28 // 14pt font
        })
      ],
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    }),
    ...paragraphs
  ]
  
  // Create document
  const doc = new Document({
    creator: metadata?.author || 'AI Law Agent',
    title: title,
    description: `${docType} generated by AI Law Agent`,
    sections: [
      {
        properties: {},
        children: documentParagraphs
      }
    ]
  })

  // Generate buffer
  const buffer = await Packer.toBuffer(doc)
  return new Uint8Array(buffer)
}

/**
 * Generate DOCX from template with placeholder replacement
 * Note: This function is intended for server-side use only
 */
export async function generateDocxFromTemplate(
  templateContent: string,
  placeholders: Record<string, string>,
  title: string,
  docType: DocumentType = 'delaware_charter'
): Promise<Uint8Array> {
  try {
    // Replace placeholders
    let processedContent = templateContent
    for (const [key, value] of Object.entries(placeholders)) {
      const placeholder = `{{${key}}}`
      processedContent = processedContent.replace(new RegExp(placeholder, 'g'), value)
    }
    
    // Convert to DOCX
    return await generateDocx({
      title,
      content: processedContent,
      docType
    })
    
  } catch (error) {
    console.error('Error generating DOCX from template:', error)
    throw new Error('Failed to generate document from template')
  }
}

/**
 * Download DOCX file in browser
 */
export function downloadDocx(buffer: Uint8Array, filename: string) {
  const blob = new Blob([buffer], { 
    type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
  })
  
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename.endsWith('.docx') ? filename : `${filename}.docx`
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/**
 * Convert HTML table to DOCX table (for future use)
 */
export function htmlTableToDocx(htmlTable: string) {
  // Placeholder for table conversion
  // This would parse HTML tables and convert to DOCX format
  return []
}

/**
 * Validate DOCX generation options
 */
export function validateDocxOptions(options: DocxGenerationOptions): string[] {
  const errors: string[] = []
  
  if (!options.title?.trim()) {
    errors.push('Document title is required')
  }
  
  if (!options.content?.trim()) {
    errors.push('Document content is required')
  }
  
  if (options.title && options.title.length > 255) {
    errors.push('Document title is too long (max 255 characters)')
  }
  
  return errors
}